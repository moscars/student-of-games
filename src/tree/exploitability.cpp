#include "exploitability.h"

void Exploitability::compute(std::shared_ptr<PublicBeliefState> tree){
    torch::Tensor ranges = torch::ones({2, settings::numPossibleHands}) / settings::numPossibleHands;

    // if there is a card on the board
    if(tree->getBoard().size() > 0){
        // remove the cards on the board from the deck
        for(int j = 0; j < settings::numPossibleHands; j++){
            std::vector<Card> hand = settings::possibleHands[j];
            if(utils::handBlockedByBoard(hand, tree->getBoard())){
                ranges[0][j] = 0;
                ranges[1][j] = 0;
            }
        }
    }

    // normalize the ranges
    ranges[0] /= ranges[0].sum().item<float>();
    ranges[1] /= ranges[1].sum().item<float>();

    fillRanges(tree, ranges);
    computeInternal(tree);
}

void Exploitability::fillRanges(std::shared_ptr<PublicBeliefState> node, torch::Tensor ranges){
    node->ranges = ranges.clone();

    if(node->isTerminal()){
        return;
    }

    assert(node->strategy.numel() > 0);

    if(node->getPlayer() != Player::CHANCE){
        torch::Tensor checksum = node->strategy.sum(1); // sum over possible actions for each hand CxA -> C
        assert(!torch::any(node->strategy < 0).item<bool>());
        // the strategy for each hand should sum to one
        assert(!torch::any(checksum < 0.999).item<bool>());
        assert(!torch::any(checksum > 1.001).item<bool>());
    }

    std::vector<std::shared_ptr<PublicBeliefState>> children = node->getChildren();

    for(int i = 0; i < settings::numPossibleHands; i++){
        for(const Card c : node->getBoard()){
            if(utils::handBlockedByBoard(settings::possibleHands[i], {c})){
                assert(std::abs(ranges[0][i].item<float>()) < 0.0001);
                assert(std::abs(ranges[1][i].item<float>()) < 0.0001);
            }
        }
    }

    if(node->getPlayer() == Player::CHANCE){
        for(size_t i = 0; i < children.size(); i++){
            //torch::Tensor new_ranges = ranges * node->strategy.select(1, i);
            torch::Tensor new_ranges = ranges.clone();
            new_ranges[0] *= node->strategy.select(1, i);
            new_ranges[1] *= node->strategy.select(1, i);
            fillRanges(children[i], new_ranges);
        }
        return;
    }

    // the strategy for the non-acting player doesn't change when the acting player makes a move
    for(size_t i = 0; i < children.size(); i++){
        torch::Tensor new_ranges = ranges.clone();

        torch::Tensor distributionForThisAction = node->strategy.select(1, i); // select the i-th column
        // given that we now that action i was taken, we can update the ranges for the acting player proportionally
        // to the probability of taking this action

        new_ranges[static_cast<int>(node->getPlayer())] *= distributionForThisAction;

        fillRanges(children[i], new_ranges);
    }

}

void Exploitability::computeInternal(std::shared_ptr<PublicBeliefState> node){
    const Player player = node->getPlayer();
    const int playerIndex = static_cast<int>(player);

    if(node->isTerminal()){
        assert(node->getActionToThisNode() != ActionType::BET);

        torch::Tensor value;
        if(node->getActionToThisNode() == ActionType::FOLD){
            auto valueP1 = equity::getTerminalEquityFold(node->getBoard(), node->ranges[1]).first;
            auto valueP2 = equity::getTerminalEquityFold(node->getBoard(), node->ranges[0]).first;
            value = torch::stack({valueP1, valueP2});
            int foldingPlayer = static_cast<int>(utils::otherPlayer(player));
            value[foldingPlayer] *= -1;

        } else{
            value = equity::getTerminalEquityCall(node->getBoard(), node->ranges[0], node->ranges[1]).first;
        }
        
        value *= node->getPotSize();

        node->cfValues = value.clone();
        node->cfValuesBestReponse = value.clone();

    } else{

        for(size_t i = 0; i < node->getChildren().size(); i++){
            computeInternal(node->getChildren()[i]);
        }

        torch::Tensor cf_values = torch::zeros({2, settings::numPossibleHands});
        torch::Tensor cf_values_br;

        if(player == Player::CHANCE){
            cf_values_br = torch::zeros({2, settings::numPossibleHands});
            for(size_t i = 0; i < node->getChildren().size(); i++){
                cf_values += node->getChildren()[i]->cfValues;
                cf_values_br += node->getChildren()[i]->cfValuesBestReponse;
            }
        } else{
            
            const int otherIndex = static_cast<int>(utils::otherPlayer(player));
            for(size_t i = 0; i < node->getChildren().size(); i++){
                torch::Tensor distributionForThisAction = node->strategy.select(1, i);
                cf_values[playerIndex] += node->getChildren()[i]->cfValues[playerIndex] * distributionForThisAction;
                cf_values[otherIndex] += node->getChildren()[i]->cfValues[otherIndex];

                if(cf_values_br.numel() == 0){
                    // need to have a default for the max operation (to cover for negative values)
                    cf_values_br = node->getChildren()[i]->cfValuesBestReponse.clone();
                } else {
                    cf_values_br[otherIndex] += node->getChildren()[i]->cfValuesBestReponse[otherIndex];
                    cf_values_br[playerIndex] = torch::max(cf_values_br[playerIndex], node->getChildren()[i]->cfValuesBestReponse[playerIndex]);
                }
            }
        }

        node->cfValues = cf_values.clone();
        node->cfValuesBestReponse = cf_values_br.clone();

    }

    // counterfactual values weighted by the reach probability
    float cfv_infset_P1 = (node->cfValues[0].dot(node->ranges[0])).item<float>();
    float cfv_infset_P2 = (node->cfValues[1].dot(node->ranges[1])).item<float>();

    // counterfactual values weighted by the reach probability of the best response
    float cfv_br_infset_P1 = (node->cfValuesBestReponse[0].dot(node->ranges[0])).item<float>();
    float cfv_br_infset_P2 = (node->cfValuesBestReponse[1].dot(node->ranges[1])).item<float>();

    node->epsilonP1 = cfv_br_infset_P1 - cfv_infset_P1;
    node->epsilonP2 = cfv_br_infset_P2 - cfv_infset_P2;

    node->exploitability = (node->epsilonP1 + node->epsilonP2) / 2;
}